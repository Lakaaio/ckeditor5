/**
 * @license Copyright (c) 2017-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */

'use strict';

const upath = require( 'upath' );
const splitLongname = require( '../../src/helpers/split-longname' );
const chalk = require( 'chalk' );

const LINK_REGEXP = /\\?{(?:@linkapi|@link|@linksdk|@linkexample)\s+[^{]+?({[^}]+})?[^{}]*\\?}/g;

const findTargetDoclet = require( '../../src/api-builder/utils/findtargetdoclet' );
const { hasDedicatedApiPages, LONG_NAME_LABEL_REGEXP } = require( '../../src/api-builder/utils/utils' );

/**
 * Converts @link or @linkapi tags into working links to guides or API docs.
 *
 * @param {Object} page
 * @param {Object} hexo
 * @return {Boolean}
 */
module.exports = function parseLinks( page, hexo ) {
	const isSilentError = hexo.projectGlobals.common._disabledFilters.has( parseLinks.name );
	const relativeUrlHelper = hexo.extend.helper.store.relative_url;

	page.content = page.content.replace( LINK_REGEXP, match => {
		if ( match.startsWith( '\\{' ) ) {
			return match.replace( /^\\{/, '{' ).replace( /\\}$/, '}' );
		}
		if ( match.includes( 'module:' ) || match.includes( '@linkapi' ) ) {
			return linkToApi( match, page, hexo, { relativeUrlHelper, isSilentError } );
		} else if ( match.includes( '@linksdk' ) || match.includes( '@linkexample' ) ) {
			return linkToSdk( match, page, hexo, { relativeUrlHelper, isSilentError } );
		} else {
			return linkToGuide( match, page, hexo, { relativeUrlHelper, isSilentError } );
		}
	} );

	return page;
};

/**
 * @param {String} str
 * @param {Object} data
 * @param {Object} hexo
 * @param {Object} options
 * @param {Function} options.relativeUrlHelper
 * @param {Boolean} options.isSilentError
 */
function linkToApi( str, data, hexo, { relativeUrlHelper, isSilentError } ) {
	const linkMatchResult = str.match( /^{((?:@linkapi|@link)[\s\S]+)}$/ );

	if ( !linkMatchResult ) {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError
		} );
	}

	const linkContentMatchResult = linkMatchResult[ 1 ].match( /^(?:@linkapi|@link)\s*(?:@(\w+))*\s*(\S+)\s*([\s\S]*)$/ );

	if ( !linkContentMatchResult ) {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError
		} );
	}

	const projectName = linkContentMatchResult[ 1 ] || data.projectName;
	const { name, label } = splitLongname( linkContentMatchResult[ 2 ] );
	const itemName = linkContentMatchResult[ 2 ].replace( LONG_NAME_LABEL_REGEXP, '' );
	let linkText = linkContentMatchResult[ 3 ] || name;

	// Support link texts with backticks, wrapping them in <code>.
	// TODO - a naive implementation.
	if ( linkText.startsWith( '`' ) && linkText.endsWith( '`' ) ) {
		linkText = linkText.replace( '`', '<code>' ).replace( '`', '</code>' );
	}

	if ( !itemName ) {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError
		} );
	}

	const baseItemName = getBaseItemName( itemName );
	let hashWithoutPrefix = itemName.replace( baseItemName, '' ).slice( 1 );
	const hash = hashWithoutPrefix ? `#${ hashWithoutPrefix }` : '';
	const project = hexo.projectGlobals[ projectName ];

	if ( hashWithoutPrefix.includes( '-' ) ) {
		let [ type, description ] = hashWithoutPrefix.split( '-' );

		// JSDuck replaces `$` with `s-`.
		if ( type === 's' ) {
			description = `s-${ description }`;
		}

		if ( type === 'event' ) {
			hashWithoutPrefix = type;
		} else {
			hashWithoutPrefix = description;
		}
	}

	let apiSlug;

	if ( project && project.config ) {
		apiSlug = getSlug( project.config, 'api-reference' ) || 'api-reference';
	} else if ( isIgnoredProject( projectName, hexo ) || hexo.projectGlobals.common.isSingleProject ) {
		return str;
	} else {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError,
			description: `Project ${ chalk.redBright( projectName ) } is not defined.`
		} );
	}

	const basePath = projectName === data.projectName ? data.BASE_PATH : `${ projectName }/latest`;
	const fileName = getFileName( baseItemName );

	let href = relativeUrlHelper( data.path, upath.join( basePath, apiSlug, fileName + hash ) );

	if ( !project || !project.doclets ) {
		return getOutputLink( href, linkText, !!linkContentMatchResult[ 3 ] );
	}

	const targetDoclet = findTargetDoclet( project.doclets, {
		module: itemName,
		structure: baseItemName,
		member: hashWithoutPrefix,
		label
	} );

	if ( !targetDoclet ) {
		return onError( {
			value: str, source: data.source, isSilent: isSilentError, description: 'No doclet found. Link remain not transformed.'
		} );
	}

	if ( hasDedicatedApiPages( targetDoclet ) ) {
		href = relativeUrlHelper( data.path, upath.join( basePath, apiSlug, getFileName( itemName ) ) );
	} else {
		href = [
			relativeUrlHelper( data.path, upath.join( basePath, apiSlug, fileName ) ),
			encodeURI( targetDoclet.extraId )
		].join( '#' );
	}

	if ( !linkContentMatchResult[ 3 ] && targetDoclet.kind === 'event' ) {
		linkText = `event-${ targetDoclet.name }`;
	}

	return getOutputLink( href, linkText, !!linkContentMatchResult[ 3 ] );
}

/**
 * Returns parent doclet for the given item.
 * See #500.
 *
 * @param {String} itemName
 */
function getBaseItemName( itemName ) {
	const lastHashIndex = itemName.lastIndexOf( '#' );
	const lastDotIndex = itemName.lastIndexOf( '.' );
	const lastTildeIndex = itemName.lastIndexOf( '~' );

	if ( lastHashIndex !== -1 ) {
		return itemName.substring( 0, lastHashIndex );
	}

	if ( lastDotIndex !== -1 ) {
		return itemName.substring( 0, lastDotIndex );
	}

	if ( lastTildeIndex !== -1 ) {
		return itemName.substring( 0, lastTildeIndex );
	}

	return itemName;
}

function getFileName( itemName ) {
	return itemName.replace( /[/:.]/g, '_' ).replace( '~', '-' ) + '.html';
}

function getOutputLink( href, description, isCustomDescription ) {
	if ( isCustomDescription ) {
		return `<a href=${ href }>${ description }</a>`;
	}

	return `<a href=${ href }><code>${ description }</code></a>`;
}

/**
 * @param {String} str
 * @param {Object} data
 * @param {Object} hexo
 * @param {Object} options
 * @param {Function} options.relativeUrlHelper
 * @param {Boolean} options.isSilentError
 */
function linkToSdk( str, data, hexo, { relativeUrlHelper, isSilentError } ) {
	const regExp = /(?:@linksdk|@linkexample) (?:@(\w+) )?(\w+)(?:\.html)?(#\S+)? ([^}]+)/;
	const match = regExp.exec( str );

	if ( !match ) {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError
		} );
	}

	const projectName = match[ 1 ] ? match[ 1 ] : data.projectName;
	const sdkSlug = getSlug( hexo.projectGlobals[ projectName ].config, 'sdk' );
	const basePath = projectName === data.projectName ? data.BASE_PATH : `${ projectName }/latest`;
	const sdkFileName = match[ 2 ];
	const sdkFileHash = match[ 3 ] || '';
	const sdkLinkName = match[ 4 ];
	const link = relativeUrlHelper( data.path, upath.join( basePath, sdkSlug, sdkFileName ) );

	return `<a href="${ link }.html${ sdkFileHash }">${ sdkLinkName }</a>`;
}

/**
 * @param {String} str
 * @param {Object} data
 * @param {Object} hexo
 * @param {Object} options
 * @param {Function} options.relativeUrlHelper
 * @param {Boolean} options.isSilentError
 */
function linkToGuide( str, data, hexo, { relativeUrlHelper, isSilentError } ) {
	const rgxp = /@link(?:\s+@(\w+))?\s+([^}\s]+)\s*([^}]*)}/;
	const match = rgxp.exec( str );

	if ( !match ) {
		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError
		} );
	}

	const pathToGuideSplit = match[ 2 ].split( '#' );
	const pathToGuide = pathToGuideSplit[ 0 ];
	const hash = pathToGuideSplit.length > 1 ? `#${ pathToGuideSplit[ 1 ] }` : '';
	const linkText = match[ 3 ] ? match[ 3 ] : pathToGuide;
	const projectName = match[ 1 ] ? match[ 1 ] : data.projectName;
	const pagePaths = hexo.projectGlobals[ projectName ] ? hexo.projectGlobals[ projectName ].pagePaths : null;

	if ( shouldIgnoreGuideLink( match, data, projectName, hexo ) ) {
		if ( isIgnoredProject( projectName, hexo ) || hexo.projectGlobals.common.isSingleProject ) {
			return str;
		}

		return onError( {
			value: str,
			source: data.source,
			isSilent: isSilentError,
			description: `Project ${ chalk.redBright( projectName ) } is not defined.`
		} );
	}

	const projectBasePath = match[ 1 ] ? hexo.projectGlobals[ projectName ].BASE_PATH : data.BASE_PATH;

	let targetPath;

	if ( pathToGuide === 'index' ) {
		targetPath = upath.join( projectBasePath, 'index.html' );
	} else {
		if ( !pagePaths ) {
			return onError( {
				value: str,
				source: data.source,
				isSilent: isSilentError
			} );
		}

		// pathToGuide is guide's physical path in project directory before being processed by hexo.
		// That's why it's found by oldDataPath.
		const pagePathData = pagePaths.find( p => {
			const minusBasePath = p.oldDataPath.replace( projectBasePath + '/', '' );
			const minusExtension = minusBasePath.substring( 0, minusBasePath.lastIndexOf( '.' ) );

			return minusExtension === pathToGuide;
		} );

		if ( !pagePathData && pathToGuide !== 'index' ) {
			return onError( {
				value: str,
				source: data.source,
				isSilent: isSilentError
			} );
		}

		targetPath = pagePathData.newDataPath;
	}

	const href = relativeUrlHelper( data.path, targetPath );

	return `<a href=${ href }${ hash }>${ linkText }</a>`;
}

/**
 * @param {String} value An expression that could not be transformed into a link.
 * @param {String} source A path to the file where the link was found.
 * @param {Boolean} [isSilent] Whether to report an error when conversion into the link failed.
 * @param {String} [description] Optional message describing the error.
 * @return {String}
 */
function onError( { value, source, isSilent, description } ) {
	if ( !isSilent ) {
		process.exitCode = 1;

		console.log(
			`${ chalk.red( 'Error: ' ) }Failed while convert ${ chalk.cyanBright( value ) } tag in ` +
			`${ chalk.magentaBright( source ) }.${ description ? chalk.italic( ' ' + description ) : '' }`
		);
	}

	return value;
}

function isIgnoredProject( projectName, hexo ) {
	return hexo.projectGlobals.common.ignoredProjects.includes( projectName );
}

function getSlug( config, name ) {
	if ( config && Array.isArray( config.groups ) ) {
		const group = config.groups.find( g => g.id === name );

		return group.slug;
	}

	return null;
}

/**
 * When linking to an external project and the documentation is being built for a single project, the link should remain untouched.
 *
 * However, if the link points to the same project, let's transform it. See #914.
 *
 * @param {Object} match
 * @param {Object} page
 * @param {String} projectName
 * @param {Object} hexo
 * @return {Boolean}
 */
function shouldIgnoreGuideLink( match, page, projectName, hexo ) {
	// If the project `{@link @projectName ...}` is not specified, the URL should be transformed.
	if ( !match[ 1 ] ) {
		return false;
	}

	// Also, if the `page` belongs to the same project as `@projectName`, the link should be transformed.
	if ( match[ 1 ] === page.projectName ) {
		return false;
	}

	// Building the single project or the project does not exist. Do not transform links.
	return ( hexo.projectGlobals.common.isSingleProject || !hexo.projectGlobals[ projectName ] );
}
