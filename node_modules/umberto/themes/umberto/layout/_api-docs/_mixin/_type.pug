include ./_link-or-text.pug

mixin type( types, isOptional = false )
	each nameOrObject, index in types
		+renderType( nameOrObject )

		if index < types.length - 1
			| !{ ' | ' }

	if ( isOptional && !types.includes( 'undefined' ) )
		| !{ ' | ' }
		+renderType( 'undefined' )

//- TODO: Description.
//-
//- @param {String|*} inlineObjectOrType
mixin renderStringValue( inlineObjectOrType )
	//- An inline object specified as string.
	if ( typeof inlineObjectOrType === 'string' && inlineObjectOrType.startsWith( '{' ) )
		| !{ inlineObjectOrType }
	else
		+linkOrText( inlineObjectOrType, {
			aClass: 'collapsing-list__type'
		} )

//- TODO: Description.
//-
//- @param {Object} complexType
//- @param {'function'|'predicate'|'operator'|'generic'} complexType.type
//- @param {Array.<*>} [complexType.params]
//- @param {String} [complexType.name]
//- @param {Array.<*>} [complexType.instances]
//- @param {String} [complexType.operator]
//- @param {Array.<*>} [complexType.values]
//- @param {String} [complexType.name]
//- @param {Array.<*>} [complexType.typeParameters]
mixin renderComplexStructure( complexType )
	//- Inline callback.
	if ( complexType.type === 'function' && complexType.params && complexType.returns )
		+renderInlineFunction( complexType )

	//- Predicate.
	//-
	//- The goal is to display whether an object is an instance of an array of modules.
	//- E.g.: `this is "Model"`
	if ( complexType.type === 'predicate' && complexType.name && complexType.instances )
		i= complexType.name
		| !{ ' is ' }
		+renderUnion( complexType.instances )

	//- Type operator.
	//-
	//- The goal is to display the type operator keyword before rendering a type.
	if ( complexType.type === 'operator' && complexType.operator && complexType.values )
		i= complexType.operator
		| !{ ' ' }
		+renderType( complexType.values )

	//- An object with type arguments.
	if ( complexType.type === 'generic' && complexType.name && ( complexType.typeParameters || complexType.typeParameter ) )
		+renderGenericType( complexType )


//- Renders a structure for an union, an array or a single type specified as a string.
//-
//-	* Union: Foo | Bar | Baz
//-	* Array: Array<Foo | Bar | Baz>
//-	* String: Foo
//-
//- All types are linkable if they point to an existing JSDoc doclet.
//-
//- @param {Set|Array|String} type
mixin renderType( type )
	//- Because of `typeof null === 'object'`...
	if ( type )
		//- Backward compatibility, when passing a `module:...` string.
		if ( typeof type === 'string' )
			+renderStringValue( type )
		else
			//- Complex structures introduced when generating API pages from TypeScript.
			if ( type instanceof Set )
				+renderUnion( [ ...type ] )
			else if ( Array.isArray( type ) )
				| !{ 'Array&lt;' }
				+renderUnion( type )
				| !{ '&gt;' }
			else if ( typeof type === 'object' )
				+renderComplexStructure( type )

//- Renders an union structure, e.g., `Foo | Bar | Baz`.
//-
//- All types are linkable if they point to an existing JSDoc doclet.
//-
//- @param {Array.<String>} type
mixin renderUnion( iterable )
	each item, index in iterable
		+renderType( item )
		if index < iterable.length - 1
			| !{ ' | ' }

//- Draws an inline callback structure.
//-
//- E.g.: `( ArgumentFoo | ArgumentBar, AnotherArgument ) => ReturnType`
//- If specified names are modules, they should point to the proper API page.
//-
//- @param {Object} callback
//- @param {String} callback.type
//- @param {Array} callback.params
//- @param {Object} callback.returns
//- @param {Boolean} callback.isClass
mixin renderInlineFunction( callback )
	if ( callback.isClass )
		i !{ 'new' }
		| !{ ' ' }

	//- (1) Start with an opening parenthesis.
	//- It prints `( ` or `(` depending on required arguments by a callback.
	if ( callback.params.length )
		| (!{ ' ' }
	else
		| (

	//- (2) Arguments parsing. They are seperated by coma (`, `).
	each paramObject, paramIndex in callback.params
		//- (3) Process a single argument.
		+renderType( paramObject )
		if paramIndex < callback.params.length - 1
			| !{ ', ' }

	//- (4) Close the parenthesis. Define the returned type.
	//- It prints ` ) => ` or `) => ` depending on required arguments by the callback.
	if ( callback.params.length )
		| !{ ' ' }) =&gt; !{ ' ' }
	else
		| ) =&gt; !{ ' ' }

	//- Wraps the returned type in brackets to avoid confusions if a type is returned by the callback,
	//- or it is a new type (outside the callback). See #1063.
	if ( callback.returns instanceof Set )
		| (!{ ' ' }

	//- (5) Process the returned type that can be an union, an array of a type.
	+renderType( callback.returns )

	//- See #1063.
	if ( callback.returns instanceof Set )
		| !{ ' ' })

//- TODO: Description
//-
//- @param {Object} generic
//- @param {'generic'} generic.type
//- @param {String} generic.name
//- @param {Set.<String>} generic.names
//- @param {Array.<*>} [generic.typeParameters]
//- @param {*} [generic.typeParameter]
mixin renderGenericType( generic )
	+renderType( generic.name )

	if ( generic.typeParameters )
		| !{ '&lt;' }
		each type, typeIndex in generic.typeParameters
			if ( typeof type === 'string' )
				+renderStringValue( type )
			else
				//- Nested generics.
				+renderGenericType( type )

			if typeIndex < generic.typeParameters.length - 1
				| !{ ', ' }
		| !{ '&gt;' }

	if ( generic.typeParameter )
		| !{ '&lsqb; ' }
		+renderType( generic.typeParameter )
		| !{ ' &rsqb;' }

