/**
 * @license Copyright (c) 2017-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */

'use strict';

const AbstractParser = require( './abstractparser' );

module.exports = class TypeParser extends AbstractParser {
	/**
	 * @param {TypedocReflectionMeta} item
	 * @returns {Boolean}
	 */
	canParse( item ) {
		return item.kindString === 'Type alias';
	}

	/**
	 * @param {TypedocReflection<'Type alias'>} item
	 * @param {String} parentName
	 * @returns {Object}
	 */
	parse( item, parentName ) {
		const result = {
			name: item.name,
			memberof: parentName,
			longname: this.getLongName( item, parentName ),

			scope: 'inner',
			kind: this.getKind( item ),
			extraId: this.getExtraId( item ),
			file: this.getFile( item ),
			skipSource: this.shouldSkipSource( item ),
			description: this.getComment( item ),
			deprecated: this.isDeprecated( item ),

			// This property will be filled in the post-processing phase.
			typeParameters: null
		};

		// There are two distinct type definitions that are rendered in own way by Umberto: function type and object type.
		// For function type, its params and return type is displayed. For object, all its properties are shown.
		const isFunctionType = item.type.declaration && item.type.declaration.signatures;

		if ( isFunctionType ) {
			// Needed for post-processing once all project reflections are converted.
			result._signature = item.type.declaration.signatures[ 0 ];

			result.description = this.getComment( result._signature );
			result.type = {
				names: [
					'function'
				]
			};

			// These properties will be filled in the post-processing phase.
			result.returns = null;
			result.params = null;
		} else {
			// Needed for post-processing once all project reflections are converted.
			result._signature = item;

			// These properties will be filled in the post-processing phase.
			result.properties = null;
			result.type = null;
		}

		return result;
	}
};
