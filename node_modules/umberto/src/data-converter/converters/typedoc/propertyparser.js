/**
 * @license Copyright (c) 2017-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */

'use strict';

const AbstractParser = require( './abstractparser' );

module.exports = class PropertyParser extends AbstractParser {
	/**
	 * @param {TypedocReflectionMeta} item
	 * @returns {Boolean}
	 */
	canParse( item ) {
		return item.kindString === 'Property' && item.name !== 'constructor';
	}

	/**
	 * @param {TypedocReflection<'Property'>} item
	 * @param {String} parentName
	 * @returns {Object}
	 */
	parse( item, parentName ) {
		// By default, a comment that is associated in the source code with the property, is bound to the item itself, as anyone would
		// expect. TypeDoc works differently for a callable property, for which the comment is moved down to the property signature.
		// Hence, we must extract it back from the property signature to be able to display it correctly in the API docs.
		const description = isCallableProperty( item ) ?
			this.getComment( item.type.declaration.signatures[ 0 ] ) :
			this.getComment( item );

		return {
			// Needed for post-processing once all project reflections are converted.
			_signature: [ item, {} ],

			name: item.name,
			memberof: parentName,
			longname: this.getLongName( item, parentName ),

			scope: this.getScope( item ),
			readonly: this.isReadonly( item ),
			observable: this.isObservable( item ),
			access: this.getVisibility( item ),
			optional: this.isOptional( item ),
			kind: this.getKind( item ),
			extraId: this.getExtraId( item ),
			description,
			file: this.getFile( item ),
			skipSource: this.shouldSkipSource( item ),
			deprecated: this.isDeprecated( item ),
			inherited: !!item.inheritedFrom,
			see: this.getRelated( item, parentName ),
			defaultvalue: this.getDefault( item ),

			// This property will be filled in the post-processing phase.
			type: null
		};
	}

	/**
	 * Returns the default value of an item defined by the `@defaultValue` or `@default` tags.
	 *
	 * @param {TypedocReflection} item
	 * @returns {String}
	 */
	getDefault( item ) {
		if ( !item.comment || !item.comment.blockTags ) {
			return null;
		}

		const defaultTag = item.comment.blockTags.find( blockTag => blockTag.tag === '@defaultValue' || blockTag.tag === '@default' );

		if ( !defaultTag ) {
			return null;
		}

		return defaultTag.content[ 0 ].text;
	}
};

/**
 * @param {TypedocReflectionType} item
 * @returns {Boolean}
 */
function isCallableProperty( item ) {
	if ( item.type.type !== 'reflection' ) {
		return false;
	}

	if ( !Array.isArray( item.type.declaration.signatures ) ) {
		return false;
	}

	return true;
}
