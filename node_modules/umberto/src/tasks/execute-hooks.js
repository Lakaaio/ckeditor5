/**
 * @license Copyright (c) 2017-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */

'use strict';

const upath = require( 'upath' );

/**
 * This function executes all hooks of the specified type for each config passed in the configs array.
 * Each hook should be a path to desired function. Hooks object in the config should look like so:
 *
 * "hooks": {
 *     "beforeHexo": [
 *         "../path/to/function_one.js",
 *         "../path/to/function_two.js"
 *     ],
 *     "afterHexo": [
 *         "../path/to/function_three.js"
 *     ]
 * }
 *
 * @param {Array} configs Array of all the configurations that might contain hooks to execute.
 * @param {String} hookName Name of a hook to execute, either 'beforeHexo' or 'afterHexo'.
 * @returns {Promise}
 */
module.exports = function executeHooks( configs, hookName ) {
	let promise = Promise.resolve();

	for ( const config of configs ) {
		if ( !config.hooks || !config.hooks[ hookName ] ) {
			continue;
		}

		for ( const scriptPath of config.hooks[ hookName ] ) {
			const callbackAbsolutePath = upath.join( upath.dirname( config.__configPath ), scriptPath );

			promise = promise
				.then( () => {
					// The `callback` may be synchronous function. Let's wrap it in the promise chain.
					return new Promise( resolve => {
						const callback = require( callbackAbsolutePath );

						return resolve( callback() );
					} ).catch( error => {
						// Store a path to the executed file.
						error._filePath = scriptPath;

						// Rejecting the promise allows catching it later.
						return Promise.reject( error );
					} );
				} );
		}
	}

	return promise.catch( error => {
		console.error( `The "${ hookName }" hook pointing to the "${ error._filePath }" file ended with an error.`, error.message );

		// Re-throwing the error as we want to break the build process.
		throw error;
	} );
};
