/**
 * @license Copyright (c) 2017-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */

'use strict';

const upath = require( 'upath' );
const hexoManager = require( '../hexo-manager' );
const copyDocFiles = require( './copy-files' );
const DOC_FORMATS = require( '../helpers/doc-formats' );

/**
 * Copies project documentation files (guides written in markdown, assets etc) to hexo source directory.
 *
 * @param {String} rootPath
 * @param {Object} config
 * @param {Object} options
 * @param {Array.<String>|null} options.match An array containing names of files that should be copied. It allows specifying name of files
 * that will be processed by Umberto.
 * @param {String} options.globalRootPath
 * @param {Array.<String>|null} [options.additionalDocumentation]
 * @returns {Promise}
 */
module.exports = ( rootPath, config, options ) => {
	const {
		globalRootPath = '',
		additionalDocumentation = null,
		match
	} = options;

	const BASE_PATH = upath.join( config.slug, config.version );
	const apiConfig = config.groups ? config.groups.find( group => group.id === 'api-reference' ) : null;
	const sdkConfig = config.groups ? config.groups.find( group => group.id === 'sdk' ) : null;
	const ignored = [ '*.json' ];
	const promises = [];
	const allOutputPaths = [];

	if ( apiConfig ) {
		ignored.push( upath.join( apiConfig.sourceDir, `*.${ DOC_FORMATS[ apiConfig.type ] }` ) );
	}

	if ( sdkConfig ) {
		ignored.push( upath.join( sdkConfig.sourceDir, '*' ) );
		ignored.push( upath.join( sdkConfig.sourceDir, '**', '*' ) );
	}

	hexoManager.addOriginPath( upath.join( rootPath, config.path ), upath.join( hexoManager.getSourceDir(), BASE_PATH ) );

	// Copy core doc files to hexo.
	promises.push( copyDocFiles(
		upath.join( rootPath, config.path ),
		upath.join( hexoManager.getSourceDir(), BASE_PATH ),
		{ match, ignored, allOutputPaths }
	) );

	// Copy doc files of packages/sub-repos.
	if ( config.items && Array.isArray( config.items ) ) {
		for ( const item of config.items ) {
			hexoManager.addOriginPath(
				upath.join( rootPath, item.path, config.path ),
				upath.join( hexoManager.getSourceDir(), BASE_PATH )
			);

			promises.push( copyDocFiles(
				upath.join( rootPath, item.path, config.path ),
				upath.join( hexoManager.getSourceDir(), BASE_PATH ),
				{
					match,
					allOutputPaths,
					ignored: [
						// `docs/constants.js` provides tokens and license keys that should not be copied.
						'constants.js'
					]
				}
			) );
		}
	}

	if ( additionalDocumentation && Array.isArray( additionalDocumentation ) ) {
		for ( const additionalDocumentationPath of additionalDocumentation ) {
			hexoManager.addOriginPath(
				upath.join( globalRootPath, additionalDocumentationPath, config.path ),
				upath.join( hexoManager.getSourceDir(), BASE_PATH )
			);

			promises.push( copyDocFiles(
				upath.join( globalRootPath, additionalDocumentationPath, config.path ),
				upath.join( hexoManager.getSourceDir(), BASE_PATH ),
				{ match, allOutputPaths }
			) );
		}
	}

	return Promise.all( promises )
		.then( files => {
			const filesMap = new Map();

			for ( const item of [].concat( ...files ) ) {
				filesMap.set( item.destinationPath, item.sourcePath );
			}

			hexoManager.hexo.projectGlobals.common._copiedFiles.set( config.slug, filesMap );
		} );
};
